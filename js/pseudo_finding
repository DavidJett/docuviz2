Pseudo code for segments finding

convertToLocationBased: function(segmentsArray)
	var result = [];
	var locationSoFar = 0;

    for (var i = 0; i < segmentsArray.length; i++) {

        if (i === 0) {
            result.push(that.findParentSegmentHelper(segmentsArray[i].segStr.length, segmentsArray[i]));
        } else {
            result.push(that.findParentSegmentHelper((findParentSegmentHelperArray[locationSoFar].locationBasedOnLength + segmentsArray[i].segStr.length), segmentsArray[i]));
            locationSoFar += 1;
        };
    };

	return result;


totalLength: function(segmentsArray){
	var total;
	_.each(segmentsArray, function(eachSegment){
		total += eachSegment.segStr.length;

	});
	return total;
};




buildSegmentsWhenInsertForDocuviz: function(entry, startIndex, author, segmentsArray){
    var that = this;
    var segmentsBefore = that.buildSegmentsBefore(entry, startIndex, author, segsmentsArray);
    var segmentsAfter = that.buildSegmentsAfter(entry, startIndex, author, segmentsArray);

},




buildSegmentsBefore: function(entry,startIndex, author, segmentsArray){

	var segmentsBefore = [];
	var that = this;
	var locationBased = that.converToLocationBased(segmentsArray);

    _.each(locationBased, function(eachSegment) {
        if (eachSegment.locationBasedOnLength <= startIndex) {
            segmentsBefore.push(eachSegment.segmentID);
        };
    }); 

    _.find(locationBased, function(eachSegment) {
        if (eachSegment.locationBasedOnLength <= startIndex) {
            var belongTo = eachSegment;
        };
    }); 


    if (author === belongTo.author){
    	segmentsBefore.pop();

    	var strInBelongTo = belongTo.segStr;

    	strInBelongTo.insert(entry,(startIndex-that.totalLength(segmentsBefore)) -1);

    	newSegment = that.constructSegment(belongTo.author, strInBelongTo, belongTo.segID, belongTo.parentSegID, belongTo.offset, belongTo.revID);

    	segmentsBefore.push(newSegment);

    }

    else if (author != belongTo.author){
    	segmentsBefore.pop();

    	var strInBelongTo = belongTo.segStr;

    	var strFromOld = strInBelongTo.substring(that.totalLength(segmentsBefore), startIndex-that.totalLength(segmentsBefore));

    	oldSegment = that.constructSegment(belongTo.author, strFromOld, belongTo.currentSegID, belongTo.parentSegID, belongTo.offset, belongTo.revID);

    	segmentsBefore.push(oldSegment);

    	that.currentSegID += 1
    	newSegment = that.constructSegment(author, entry, that.currentSegID, -1, belongTo.offset, belongTo.revID);

    	segmentsBefore.push(newSegment);

    };

    return segmentsBefore;
	
},


buildSegmentsAfter: function(entry,startIndex, author, segmentsArray){

	var segmentsAfter = [];
	var that = this;
	var locationBased = that.converToLocationBased(segmentsArray);

    _.each(locationBased, function(eachSegment) {
        if (eachSegment.locationBasedOnLength >= startIndex) {
            segmentsAfter.push(eachSegment.segmentID);
        };
    }); 

    _.find(locationBased, function(eachSegment) {
        if (eachSegment.locationBasedOnLength >= startIndex) {
            var belongTo = eachSegment;
        };
    }); 


    if (author === belongTo.author){
    	segmentsAfter.shift(); // remove the first element of the array because the author is the same, we handle it in Before

    }

    else if (author != belongTo.author){
    	segmentsAfter.shift();

    	var strInBelongTo = belongTo.segStr;

    	var strFromOld = strInBelongTo.substring((startIndex-that.totalLength(segmentsBefore))+1, locationBased.slice(-1)[0].locationBasedOnLength);

    	newSegment = that.constructSegment(belongTo.author, strFromOld, belongTo.segID, belongTo.parentSegID, belongTo.offset, belongTo.revID);

    	segmentsAfter.unshift(newSegment);

    };
    return segmentsAfter;

},


deleteSegments: function(deleteStartIndex, deleteEndIdex, author, segsmentsArray){
    var segmentsBefore = [];
    var segmentsAfter = [];
    var that = this;
    var locationBased = that.converToLocationBased(segmentsArray);

    _.each(locationBased, function(eachSegment) {
        if (eachSegment.locationBasedOnLength <= deleteStartIndex) {
            segmentsBefore.push(eachSegment.segmentID);
        };
    }); 

     _.each(locationBased, function(eachSegment) {
        if (eachSegment.locationBasedOnLength >= deleteStartIndex) {
            segmentsAfter.push(eachSegment.segmentID);
        };
    });   


    var belongToDeleteStartIndex = segmentsBefore[segmentsBefore.length-1];
    var belongToDeleteEndIndex = segmentsAfter[0];

    if (segmentsBefore.length > 0){
        segmentsBefore.pop();


    };    

    if (segmentsAfter.length > 0){
        segmentsAfter.shift();
    };
    

},




BACKUP:




                        if (tempSegsArray.length > 0){
                            console.log("segmentsAfter BELONG TO:");

                            console.log(tempSegsArray[0]);

                            console.log("*******--------******")
                            // find the segments that the current insert index is belong to
                            var belongTo = tempSegsArray[0];


                            if (author === belongTo.author){
                                tempSegsArray.shift(); // remove the first element of the array because the author is the same, we handle it in Before
                                console.log("AUTHOR ===== BELONGTO.AUTHOR");
                            }

                            else if (author != belongTo.author){

                                tempSegsArray.shift(); // remove the first element, substring and then push to the first again.


                                if (tempSegsArray.length === 0){
                                    var strInBelongTo = belongTo.segStr;
                                    var strFromOld = strInBelongTo.substring(startIndex-1, strInBelongTo.length);

                                    var newSegment = that.constructSegment(belongTo.author, strFromOld, belongTo.segID, belongTo.parentSegID, belongTo.offset, belongTo.revID,0,0,"from buildSegmentsAfter when length === 0 ");

                                    tempSegsArray.unshift(newSegment);
                                }

                                else{

                                    var strInBelongTo = belongTo.segStr;

                                    //var strFromOld = strInBelongTo.substring(startIndex+1, locationBased.slice(-1)[0].locationBasedOnLength);

                                    var strFromOld = strInBelongTo.substring((startIndex-that.totalLength(segmentsBefore)+1), strInBelongTo.length);

                                    var newSegment = that.constructSegment(belongTo.author, strFromOld, belongTo.segID, belongTo.parentSegID, belongTo.offset, belongTo.revID,0,0,"from buildSegmentsAfter");

                                    tempSegsArray.unshift(newSegment);


                                };
                            



                            };

                        }

